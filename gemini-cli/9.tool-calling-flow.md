# Gemini CLI 工具调用与执行流程解析

本文档深入解析了 Gemini CLI 从接收 LLM 的工具调用请求到安全执行工具并返回结果的完整内部流程。

## 1. 流程概述

工具调用是 Gemini CLI 的核心功能之一，它允许 LLM 执行本地操作（如读写文件、运行命令）以完成更复杂的任务。整个流程被设计成一个健壮的、包含状态管理、用户批准和流式 I/O 的闭环系统。

**核心组件**:

- **`useGeminiStream`**: UI 层的“总指挥”，负责从 LLM 事件流中解析工具调用请求，并在工具执行完毕后将结果发回。
- **`useReactToolScheduler`**: UI 层的“适配器”，将核心调度逻辑与 React UI 连接起来。
- **`CoreToolScheduler`**: `core` 包中的“调度引擎”，一个与 UI 无关的类，负责管理工具调用的完整生命周期。
- **`ToolRegistry`**: `core` 包中的“工具注册中心”，负责存储、查找和提供所有可用工具的定义与实现。
- **`Tool` 实现** (如 `ShellTool`): `core` 包中每个工具的具体实现，包含其 Schema、批准逻辑和执行逻辑。

**流程图:**

```
LLM (生成 ToolCallRequest)
        ↓
[UI] useGeminiStream (解析事件)
        ↓
[UI] useReactToolScheduler (调用 schedule)
        ↓
[Core] CoreToolScheduler (核心状态机与调度引擎)
        ↓
[Core] ToolRegistry (查找工具实例)
        ↓
[Core] ToolInvocation (执行 shouldConfirmExecute)
        │
        ├─> (需要批准) ─> [UI] 显示确认对话框 ─> (用户批准)
        │
        ↓ (无需批准或已批准)
[Core] ToolInvocation (执行 execute)
        ↓
[Core] CoreToolScheduler (接收结果, 更新状态为 success)
        ↓
[UI] useReactToolScheduler (通过 onComplete 回调通知)
        ↓
[UI] useGeminiStream (打包结果为 FunctionResponse)
        ↓
LLM (接收工具执行结果)
```

## 2. 详细执行步骤

### 步骤 1: LLM 发出请求

当 LLM 在其推理过程中决定需要执行一个本地操作时，它不会直接生成答案，而是生成一个包含 `toolCall` 的响应。例如：

```json
{
  "toolCall": {
    "name": "run_shell_command",
    "args": {
      "command": "ls -l /Users"
    }
  }
}
```

### 步骤 2: 解析与调度

1.  UI 层的 `useGeminiStream` 在其核心事件循环 `processGeminiStreamEvents` 中监听到 `ToolCallRequest` 事件。
2.  它将一个或多个工具调用请求收集起来，然后调用 `scheduleToolCalls` 函数。
3.  `scheduleToolCalls` 实际上调用的是 `useReactToolScheduler` Hook 返回的 `schedule` 方法，并将请求传递给 `CoreToolScheduler` 实例。

### 步骤 3: 核心调度与状态机 (`CoreToolScheduler`)

`CoreToolScheduler` 是整个流程的引擎，它为每个工具调用维护一个状态机。

1.  **验证 (Validating)**: 
    *   调度器接收到请求后，首先通过 `ToolRegistry` 查找名为 `run_shell_command` 的工具实例。
    *   如果找不到，该工具直接进入 `error` 状态。
    *   如果找到，则调用该工具的 `createInvocation()` 方法创建一个 `ShellToolInvocation` 实例，并将工具状态置为 `validating`。

2.  **请求批准 (Awaiting Approval)**:
    *   调度器调用 `ShellToolInvocation` 实例的 `shouldConfirmExecute()` 方法。
    *   该方法是**安全门禁**，它会检查 `ls` 命令是否在用户已经“总是允许”的白名单 (`allowlist`) 中。
    *   由于 `ls` 首次执行时不在白名单中，`shouldConfirmExecute()` 返回一个包含确认提示信息的对象。
    *   调度器收到这个对象后，将工具状态切换为 `awaiting_approval`，并通过 `onToolCallsUpdate` 回调通知 UI 层。
    *   UI 层收到更新，渲染一个确认对话框：“确认执行命令: ls -l /Users? [是] [否] [总是允许]”。此时，流程暂停，等待用户输入。

3.  **计划 (Scheduled)**:
    *   用户点击“[是]”或“[总是允许]”。
    *   UI 调用从调度器那里获得的 `onConfirm` 回调函数。
    *   调度器收到用户的批准决策。如果用户选择了“总是允许”，则将 `ls` 添加到 `allowlist` 中。
    *   调度器将工具状态切换为 `scheduled`。

### 步骤 4: 执行与流式输出

1.  **执行 (Executing)**:
    *   调度器调用 `attemptExecutionOfScheduledCalls` 方法，找到所有处于 `scheduled` 状态的工具。
    *   它将工具状态切换为 `executing`，并调用 `ShellToolInvocation` 的 `execute()` 方法。

2.  **底层执行**: 
    *   `execute()` 方法内部调用 `ShellExecutionService`，后者使用 `node-pty` 库在一个伪终端中安全地启动 `ls -l /Users` 子进程。
    *   `node-pty` 能够捕获包括 ANSI 颜色在内的原始终端输出。

3.  **流式输出**: 
    *   当 `ls -l` 命令产生输出时，`ShellExecutionService` 会通过回调函数将数据块（chunk）实时地传递回来。
    *   这个回调一路上传，最终触发 `useReactToolScheduler` 中的 `outputUpdateHandler`，后者更新 React 的 state，使得命令的输出能够被实时渲染在用户的 CLI 界面上。

### 步骤 5: 处理结果与返回

1.  **成功 (Success)**:
    *   `ls -l` 命令执行完毕，`ShellExecutionService` 返回最终的完整输出、退出码等结果。
    *   `ShellToolInvocation` 将这些结果打包成一个 `ToolResult` 对象，其中 `llmContent` 包含了给 LLM 看的详细信息，而 `returnDisplay` 则是给用户看的简洁版本。
    *   调度器监听到 `execute()` 的 Promise 完成，将工具状态切换为 `success`。

2.  **完成通知**: 
    *   调度器调用 `checkAndNotifyCompletion`，检查发现当前批次的所有工具都已完成。
    *   它触发 `onAllToolCallsComplete` 回调，并将所有 `ToolResult` 对象传递给 `useGeminiStream`。

3.  **打包返回**: 
    *   `useGeminiStream` 中的 `handleCompletedTools` 函数被激活。
    *   它将 `ToolResult` 转换成 LLM 能理解的 `FunctionResponse` 格式。
    *   最后，它再次调用 `submitQuery`，将这个 `FunctionResponse` 作为新的上下文信息发送回 LLM。

### 步骤 6: 完成闭环

LLM 接收到 `ls -l` 命令的执行结果，就如同得到了一次外部查询的答案。它会基于这个新的信息，继续进行下一步的思考和内容生成，从而完成整个工具调用的闭环。