# Gemini CLI /shell 命令与沙箱执行流程

本文档深入解析了 Gemini CLI 中 `/shell` 命令的工作机制，以及其背后实现安全执行的沙箱（Sandbox）流程。

## 1. 流程概述

`/shell` 命令为用户提供了一个在 CLI 中直接执行原生 shell 命令的强大功能。为了安全地执行这些可能具有破坏性的命令，Gemini CLI 实现了一套复杂的沙箱机制。当沙箱启用时，CLI 会将自身重新启动到一个隔离的 Docker (或 Podman) 容器中来执行命令。

整个流程可以分为两大分支：

1.  **本地执行**: 在沙箱未启用的情况下，通过 `node-pty` 在本地启动一个伪终端来执行命令。
2.  **沙箱执行**: 在沙箱启用时，构造并执行一个 `docker run` 命令，在容器内重新运行 Gemini CLI 来执行用户的原始命令。

## 2. `/shell` 命令处理流程

此流程由 `packages/cli/src/ui/hooks/shellCommandProcessor.ts` 中的 `useShellCommandProcessor` Hook 主要负责。

1.  **命令激活**: 用户在输入框中输入 `/shell`，CLI 进入“shell 模式”。在此模式下，所有后续输入都将被视为原生 shell 命令，而不是发送给 LLM 的提示。

2.  **命令捕获**: 用户输入一条命令（如 `ls -l`）并回车。`useGeminiStream` Hook 捕获到这个输入，并判断当前处于 shell 模式，于是调用 `handleShellCommand` 函数来处理。

3.  **创建前端状态**: `handleShellCommand` 首先会在 UI 上创建一个状态为 `Executing` 的工具调用占位符，让用户知道命令正在执行。

4.  **调用执行服务**: 随后，它调用 `core` 包中的 `ShellExecutionService.execute()` 方法，将命令字符串、当前工作目录和 AbortSignal（用于取消操作）传递过去。**此时，流程进入了本地执行阶段**。

## 3. 本地执行流程 (`ShellExecutionService`)

此流程由 `packages/core/src/services/shellExecutionService.ts` 负责，它是与操作系统直接交互的层面。

1.  **选择 PTY 实现**: 该服务会尝试加载 `@lydell/node-pty` 或 `node-pty`。`node-pty` 是一个关键库，它允许 Node.js 程序像真实的终端一样，启动和控制其他进程。

2.  **创建伪终端**: `executeWithPty` 方法被调用，它使用 `pty.spawn()` 创建一个子进程。这个子进程不是直接运行用户的命令，而是启动一个真实的 shell（如 `bash` 或 `cmd.exe`），然后再由这个 shell 来执行用户的命令。

3.  **流式 I/O**: 
    *   `pty.spawn()` 返回的 `ptyProcess` 对象可以监听 `onData` 事件。
    *   当子进程（即用户命令）产生任何输出（stdout 或 stderr）时，`onData` 事件会被触发。
    *   事件处理器捕获到数据块（chunk），并通过 `onOutputEvent` 回调函数将其一路传递回 UI 层的 `shellCommandProcessor`。
    *   UI 层接收到数据后，实时更新界面，从而实现了命令输出的“流式”效果。

4.  **处理退出**: 当命令执行完毕，`ptyProcess` 触发 `onExit` 事件。`ShellExecutionService` 捕获退出码或终止信号，将最终的完整输出打包成一个 `ShellExecutionResult` 对象，并通过 Promise 返回。

5.  **更新历史**: `shellCommandProcessor` 接收到最终结果，将之前创建的占位符更新为 `Success` 或 `Error` 状态，并将完整的命令执行记录（包括命令、输出、退出码等）添加到对话历史中。

## 4. 沙箱执行流程

沙箱流程在所有其他逻辑之前，于程序启动的早期阶段介入。它由 `packages/cli/src/gemini.tsx` 中的 `main` 函数和 `packages/cli/src/utils/sandbox.ts` 中的 `start_sandbox` 函数共同完成。

1.  **沙箱检查**: `gemini.tsx` 的 `main` 函数在启动时会检查 `!process.env['SANDBOX']`。如果 `SANDBOX` 环境变量**未被设置**，并且在配置文件中启用了沙箱，则进入沙箱启动流程。

2.  **调用 `start_sandbox`**: `main` 函数调用 `start_sandbox`，并传入沙箱配置（使用 `docker` 还是 `podman`，以及镜像名称）和原始的命令行参数。

3.  **构建 Docker 命令 (`start_sandbox` 函数)**: 这是整个沙箱机制的核心。`start_sandbox` 函数会以编程方式构建一个极其复杂的 `docker run` (或 `podman run`) 命令，包含了以下关键部分：
    *   **镜像**: 使用在配置中指定的沙箱镜像 (如 `us-docker.pkg.dev/.../sandbox:latest`)。
    *   **交互式与清理**: 添加 `-i` (交互式), `-t` (TTY, 如果是交互式会话), `--rm` (容器退出后自动删除) 等参数。
    *   **工作目录挂载**: 将当前宿主机的项目目录（`process.cwd()`）挂载到容器内的同一个路径，作为工作目录。这是实现文件操作的关键。
    *   **配置挂载**: 将宿主机上的用户配置目录 (`~/.gemini`) 挂载到容器内的 `/home/node/.gemini`，从而共享配置和认证信息。
    *   **环境变量传递**: 将宿主机上必要的环境变量（如 `GEMINI_API_KEY`, `HTTPS_PROXY`, `TERM` 等）传递给容器。
    *   **设置 `SANDBOX` 环境变量**: **最关键的一步**，它在容器内设置 `SANDBOX=true`。这可以防止容器内的 Gemini CLI 进程再次尝试启动沙箱，从而避免无限递归。
    *   **入口点 (Entrypoint)**: 构建容器的入口命令。这个命令会重新执行 `gemini`，并把宿主机上收到的所有原始命令行参数（如 `--debug` 或用户输入的提示）原封不动地传递过去。

4.  **执行与替换**: 
    *   `start_sandbox` 使用 Node.js 的 `spawn` 函数执行构建好的 `docker run` 命令。
    *   `stdio` 被设置为 `inherit`，这意味着容器的 stdin, stdout, stderr 会直接连接到当前终端。
    *   此时，原始的 Gemini CLI 进程实际上变成了一个“启动器”，它的唯一作用就是启动并等待 Docker 容器。用户的所有后续交互实际上都是在与容器内的 Gemini CLI 进程进行。

5.  **容器内执行**: 容器内的 Gemini CLI 启动后，它会再次执行到 `main` 函数。但这一次，`process.env['SANDBOX']` 的值为 `true`，因此沙箱检查会失败，程序继续正常执行。当用户输入 `/shell` 命令时，该命令将在容器这个受限环境中被 `ShellExecutionService` 执行，从而实现了安全隔离。