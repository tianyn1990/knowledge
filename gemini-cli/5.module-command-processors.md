# Gemini CLI 模块解析：命令处理器

本文档深入解析了 Gemini CLI 如何处理用户输入的各种命令，包括斜杠命令 (`/`)、At 命令 (`@`) 和 Shell 模式下的命令。这是实现 CLI 丰富交互能力的核心模块。

## 1. 架构概述：责任链模式

Gemini CLI 的命令处理系统采用了经典的“责任链模式”。所有用户的输入首先由 `useGeminiStream` Hook 捕获，然后像接力棒一样，依次传递给一系列专门的处理器。如果一个处理器能够处理该输入，它就执行相应操作并终止传递；否则，就将其传递给链上的下一个处理器。

**处理链顺序**:

1.  **斜杠命令 (`/`) 处理器**: 检查输入是否以 `/` 或 `?` 开头。
2.  **Shell 模式处理器**: 检查当前是否处于由 `/shell` 命令激活的“shell 模式”。
3.  **At 命令 (`@`) 处理器**: 检查输入中是否包含 `@` 字符。
4.  **默认处理器**: 如果以上都不是，则将输入作为标准提示，发送给 LLM。

这种设计使得每种命令的处理逻辑都封装在独立的模块中，高度解耦且易于扩展。

## 2. 斜杠命令处理器 (`slashCommandProcessor.ts`)

这是最复杂也是功能最强大的处理器，它本身就是一个微型的命令框架。

### 2.1. 动态命令加载

它使用一个 `CommandService` 来动态地从多个来源发现并注册命令，实现了极高的可扩展性：

- **`BuiltinCommandLoader`**: 加载硬编码在源码中的核心命令，如 `/help`, `/quit`, `/theme`, `/config` 等。
- **`FileCommandLoader`**: 扫描特定目录（用户家目录下的 `.gemini/commands/` 和项目目录下的 `.gemini/commands/`）中的 `.js` 文件。这允许**用户通过编写一个简单的 JavaScript 文件来创建自己的自定义命令**。
- **`McpPromptLoader`**: 通过“模型上下文协议”（MCP）从外部服务（如 VS Code 插件）发现并注册命令。

### 2.2. 命令执行与依赖注入

1.  **解析**: 当用户输入如 `/config set model.name gemini-pro` 时，`parseSlashCommand` 工具函数会将其解析成命令对象、子命令路径和参数数组。
2.  **执行**: 处理器找到对应的命令对象，并执行其 `action` 方法。
3.  **`CommandContext`**: 在执行 `action` 时，会向其传递一个 `CommandContext` 对象。这是一个**依赖注入容器**，它为命令逻辑提供了访问所有核心服务（如 `config`, `git`, `logger`）和 UI 操作（如 `addItem`, `clear`）的能力。这使得命令的实现可以完全独立于 UI，极大地增强了模块化和可测试性。

### 2.3. 多样化的返回结果

`action` 方法可以返回不同类型的结果，以告知上层 `useGeminiStream` 下一步该做什么：

- `{ type: 'handled' }`: 命令已处理完毕，无需进一步操作。
- `{ type: 'schedule_tool', ... }`: 请求工具调度器执行一个工具（例如 `/run` 命令）。
- `{ type: 'submit_prompt', ... }`: 将用户输入转换为一个新的提示，再发送给 LLM（例如 `/commit` 命令）。
- `{ type: 'dialog', ... }`: 请求 UI 打开一个对话框（例如 `/theme` 命令）。
- `{ type: 'confirm_shell_commands', ... }`: 在执行高风险操作前，请求 UI 向用户弹出确认框。

## 3. At 命令处理器 (`atCommandProcessor.ts`)

`@` 命令是向 LLM 上下文注入文件或目录内容的快捷方式。

1.  **解析**: `parseAllAtCommands` 函数负责从用户输入中提取所有 `@<path>` 形式的引用，并能正确处理路径中被转义的空格。

2.  **智能转换**: 该处理器的实现非常巧妙。它并**不是自己去读取文件**，而是将用户的 `@` 命令**转换为一个对内置 `read_many_files` 工具的调用**。

3.  **客户端工具调用**: 它在客户端（而不是由 LLM 发起）直接执行这个 `read_many_files` 工具，从而获取到所有指定文件和目录的内容。

4.  **上下文注入**: 最后，它将用户原始的提示文本和从工具获取到的文件内容，共同打包成一个新的、更丰富的提示（`PartListUnion`），再返回给 `useGeminiStream`。LLM 最终收到的，将是用户的提问外加所有相关文件的完整内容。

## 4. Shell 模式处理器 (`shellCommandProcessor.ts`)

当用户执行 `/shell` 命令后，CLI 就进入了 shell 模式，此处理器被激活。

1.  **直接执行**: 在此模式下，所有用户输入都被视为原生 shell 命令。处理器会直接调用底层的 `ShellExecutionService` 来执行它，并通过回调函数将流式输出实时渲染到 UI。

2.  **让 LLM “感知” Shell**: 这是该处理器设计的点睛之笔。在 shell 命令执行完毕后，它会调用 `addShellCommandToGeminiHistory` 函数。此函数会创建一个格式化的字符串，如：

    > 我执行了命令 `ls -l`，它产生了如下结果：
    > ```
    > ... (ls -l 的输出) ...
    > ```

    然后，它将这个字符串作为一个“用户”消息，添加到与 LLM 的对话历史中。通过这种方式，LLM 能够“感知”到用户在 shell 模式下的所有操作及其结果，用户因此可以就命令的输出进行追问（例如“请解释一下刚才输出的第三列是什么意思”），实现了真正的“AI Shell”体验。