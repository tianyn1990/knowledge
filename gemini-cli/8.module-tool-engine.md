# Gemini CLI 模块解析：工具引擎 (ToolRegistry & CoreToolScheduler)

本文档深入解析了 Gemini CLI 中两个紧密协作的核心模块：`ToolRegistry` 和 `CoreToolScheduler`。它们共同构成了驱动所有工具（Tools）功能的核心引擎，负责工具的发现、管理、调度、批准和执行。

## 1. 架构概述：职责分离

为了清晰地管理工具，项目将工具的“定义”与“执行”分离开来，并由两个不同的模块负责：

- **`ToolRegistry` (工具注册中心)**: 它的职责是回答 **“有什么？”** 的问题。它是一个中央化的“工具数据库”，负责维护所有可用工具的列表，并向 LLM 提供这份能力清单。

- **`CoreToolScheduler` (核心工具调度器)**: 它的职责是回答 **“怎么做？”** 的问题。它是一个与 UI 无关的、通用的“工作流引擎”，负责接收 LLM 的工具调用请求，并管理其从“请求”到“执行”再到“完成”的整个生命周期状态。

这种“注册”与“调度”分离的设计，使得系统高度模块化，易于扩展和测试。

## 2. `Tool` 的抽象设计

在深入模块之前，需要理解单个 `Tool` 的抽象设计。每个工具都被拆分为两个部分：

1.  **`BaseDeclarativeTool` (声明部分)**: 
    *   定义了工具的 **Schema**，即符合 Google AI `FunctionDeclaration` 规范的 JSON 对象，描述了工具的名称、功能和参数。这是给 **LLM** 看的“API 文档”。
    *   它还是一个**工厂**，负责创建一个 `ToolInvocation` 实例。

2.  **`BaseToolInvocation` (调用部分)**: 
    *   代表一次**具体的工具调用**，包含了 LLM 提供的实际参数。
    *   它封装了工具的**实际执行逻辑** (`execute` 方法) 和**批准逻辑** (`shouldConfirmExecute` 方法)。

这种设计将工具的“静态定义”和“动态调用”清晰地分离开来。

## 3. `ToolRegistry`：能力的“数据库”

`ToolRegistry` 位于 `packages/core/src/tools/tool-registry.ts`，它像一个工具箱，管理着 agent 的所有能力。

- **工具存储**: 内部使用一个 `Map<string, AnyDeclarativeTool>` 来存储所有工具的实例。

- **工具来源**: 工具的来源多样，体现了系统的强大扩展性：
    1.  **内置工具**: `ShellTool`, `ReadFileTool` 等核心工具，在程序启动时被硬编码注册进来。
    2.  **命令发现**: 它可以执行一个用户配置的 `toolDiscoveryCommand` 命令。该命令的标准输出（stdout）被期望是一个工具 Schema 的 JSON 数组。注册中心会解析这个 JSON，并将其中的每一项都注册为一个可执行的 `DiscoveredTool`。
    3.  **MCP 发现**: 它还可以通过“模型上下文协议”（MCP）连接到外部服务（如 IDE 插件），并动态发现和注册来自这些服务的工具。

- **核心接口**: 
    - **`getFunctionDeclarations()`**: 这是提供给 `GeminiClient` 的“公共 API”。它遍历所有已注册的工具，收集它们的 Schema，并将其返回。`GeminiClient` 会将这份 Schema 列表随同用户的提示一起发送给 LLM，从而让 LLM 知道它“能做什么”。
    - **`getTool(name)`**: 这是提供给 `CoreToolScheduler` 的“内部 API”。当调度器需要执行一个工具时，它通过此方法获取工具的实例。

## 4. `CoreToolScheduler`：工具执行的“状态机”

`CoreToolScheduler` 位于 `packages/core/src/core/coreToolScheduler.ts`，是整个工具调用流程的“工作流引擎”。

- **状态机管理**: 调度器的核心是管理一个 `ToolCall` 对象数组，每个对象都是一个独立的状态机。其核心状态包括：
    - `validating`: 验证工具是否存在、参数是否合法。
    - `awaiting_approval`: 已暂停，等待用户在 UI 上确认执行。
    - `scheduled`: 已批准，等待执行。
    - `executing`: 正在执行中。
    - `success` / `error` / `cancelled`: 终结状态。

- **调度入口 (`schedule`)**: 当 `useGeminiStream` 收到 LLM 的工具调用请求后，会调用此方法。它接收请求，通过 `ToolRegistry` 验证工具的有效性，然后为每个调用创建一个状态机实例，并开始流转。

- **用户批准门禁**: 
    1.  在 `validating` 状态后，调度器会调用工具的 `shouldConfirmExecute()` 方法。
    2.  如果该方法返回 `false`（表示无需批准），工具状态直接进入 `scheduled`。
    3.  如果返回 `true` 或一个确认对象（表示需要批准），调度器会检查全局的 `approvalMode`。如果不是自动批准模式，则将工具状态切换为 `awaiting_approval`，并通过回调通知 UI 显示确认对话框，**执行流程在此暂停**。
    4.  当用户在 UI 上做出选择后，UI 会调用调度器提供的 `onConfirm` 回调，调度器根据用户的选择（同意、取消、总是同意）来决定是将状态推进到 `scheduled` 还是 `cancelled`。

- **并行执行**: `attemptExecutionOfScheduledCalls` 方法会查找所有处于 `scheduled` 状态的工具，并通过 `Promise.all` 或类似机制**并行地**调用它们的 `execute()` 方法。

- **与 UI 解耦**: `CoreToolScheduler` 本身不依赖任何 UI 框架。它通过一系列回调函数（如 `onToolCallsUpdate`, `onAllToolCallsComplete`）来向上层（即 `useReactToolScheduler` 适配器）报告状态的变更和最终的结果。这种设计使得这个强大的调度引擎可以被任何类型的用户界面（CLI, Web, etc.）复用。